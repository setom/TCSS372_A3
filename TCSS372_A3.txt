/*

	Matthew Seto
	TCSS 372
	Assignment 3
	
	Converting the controller to a new ISA
	
*/


#include <stdio.h>
#include <stdlib.h>
#include <limits.h>


//constants for the FSM
#define FETCH 0
#define DECODE 1
#define EXECUTE 2

//general exit Microstate
#define EXIT INT_MAX //large number higher than all microstates


//FETCH microstates
#define FETCH1 0
#define FETCH2 1
#define FETCH3 2
#define FETCH4 3

//DECODE microstate
//#define DECODE1 0

//EXECUTE microstates
#define LDI 0x1
#define LD 0x2 
//#define LD-2 3
#define ST 0x04
#define MOV 0x05
#define PUSH 0x06
#define POP 0x07
#define ADD 0x08
#define SUB 0x09
#define AND 0x0A
#define OR 0x0B
#define NOT 0x0C
#define XOR 0x0D
#define SHL 0x0E
#define SHR 0x0F
#define BR 0x10
#define BRZ 0x11
#define BRN 0x12
#define BRC 0x13
#define BRO 0x14
#define JSR 0x15
#define JSRZ 0x16
#define JSRN 0x17
#define DI 0x18
#define EI 0x19
#define RET 0x1A
#define RETI 0x1B
#define TRAP 0x1C
#define HALT 0x1D
#define NOP 0x00

//struct for a CPU
typedef struct CPU{
	//PC
	unsigned int PC;
	//MAR
	unsigned int MAR;
	//MDR 
	unsigned int MDR;
	//IR
	unsigned int IR;
	//ALU Registers
	unsigned int ALUA;
	unsigned int ALUB;
	unsigned int ALUResult;
	//array of registers 0-15
	unsigned int registers[16];
} CPU;


//***Function prototypes

//prototype to create a CPU
struct CPU *create_CPU();

//prototype to destroy the CPU
void CPU_Destroy(struct CPU *theCPU);

//prototype for getting user to press a key to continue
int pressAnyKey();


int main (int argc, char* argv[]){

	//int variables for registers
	unsigned int RD = 0; 	//destination register
	unsigned int RS1 = 0; 	//source register 1
	unsigned int RS2 = 0; 	//source register 2
	unsigned int RB = 0; 	//base register
	unsigned int immediate = 0;
	
	//initialize state
	int state = FETCH;
	int microstate = FETCH1;
	
	unsigned int instruction = 0;
	unsigned int opcode = 0;
	
	//array of system memory
	unsigned int systemMemory[100];
	
	//create the CPU
	struct CPU* myCPU = create_CPU();

	//while the state is not halt, continue looping through
	 while(state != HALT){
		switch(state){
			case FETCH :
				microstate = FETCH1;
				while(microstate < EXIT) {
					switch(microstate) {
						case FETCH1 :
							//MAR <- PC
							myCPU->MAR = myCPU->PC;
							//A <- PC
							myCPU->ALUA = myCPU->PC;
							
							//increment to the next microstate
							microstate = FETCH2;
							
							break;
						
						case FETCH2 :

							//scan the hex value that defines instruction and specific variables
							printf("Enter hex instruction: \n");
							scanf("%x", &instruction);
							
							//IR <- M[MAR] //input a number from 0-7 representing an instruction
							myCPU->IR = instruction;
							
							//increment to next microstate
							microstate = FETCH3;
							
							break;
							
						case FETCH3 :
							//printf("FETCH3\n");
							//PC<- A +1 increment the PC
							myCPU->PC = myCPU->ALUA+1;
							
							//increment the microstate
							microstate = FETCH4;
							
							break;
						
						case FETCH4 :
							//printf("FETCH4\n");
							//increment the state
							state = DECODE;
							
							//change the microstate to EXIT STATE
							microstate = EXIT;
					}
					
				}
				//printf("EXITED FETCH\n");		
			case DECODE :
				//reset the microstate
				microstate = DECODE1;
					
					
					//decode the instruction
					//preserve the first 2 hex digits and mask the remaining ones
					opcode = instruction & 0xFF000000;
					//shift to read only the first 5 digits
					opcode = opcode >> 27;
					printf("Opcode: %x\n", opcode);
					
					//switch through the appropriate microstate
					switch(opcode) {
						case 0x01 :
							microstate = LDI;
							//*** FORMAT 1 ***
							//first mask to preserve binary digits 28-21
							//then shift 23 to get to bits 28-24
							//then & with 01111 to remove the extra bit
							RD = (((instruction & 0x0FF00000) >> 23) & 01111);
							//mask the opcode and register, leave only the immediate
							immediate = (instruction & 00000000011111111111111111111111);
							break;
						case 0x02 :
							microstate = LD;
							//*** FORMAT 2 ***
							// first mask to preserve the digits 28-21
							//then shift 23 to get bits 28-24
							//then & with 01111 to remove the extra bit
							RD = (((instruction & 0x0FF00000) >> 23) & 01111);
							//mask to preserve bits 24-17
							//then shift 19 to get bits 24-20
							RB = (((instruction & 0x00FF0000) >> 19) & 01111);
							//mast the opcode, register and base register, leave the imm.
							immediate = (instruction & 00000000000001111111111111111111);
							break;
						//case 0x03 :
						//	microstate = ST;
						//	break;
//*********************************
//*********************************
//***** Thanks! *******************
						case 0x04 :
							microstate = ST;
							break;
						case 0x05 :
							microstate = MOV;
							break;
						case 0x06 :
							microstate = PUSH;
							break;
						case 0x07 :
							microstate = POP;
							break;
						case 0x08 :
							microstate = ADD;
							break;
						case 0x09 :
							microstate = SUB;
							break;
						case 0x0A :
							microstate = AND;
							break;
						case 0x0B :
							microstate = OR;
							break;		
						case 0x0C :
							microstate = NOT;
							break;
						case 0x0D :
							microstate = XOR;
							break;
						case 0x0E :
							microstate = SHL;
							break;
						case 0x0F :
							microstate = SHR;
							break;
						case 0x10 :
							microstate = BR;
							break;
						case 0x11 :
							microstate = BRZ;
							break;
						case 0x12 :
							microstate = BRN;
							break;
						case 0x13 :
							microstate = BRC;
							break;			
						case 0x14 :
							microstate = BRO;
							break;
						case 0x15 :
							microstate = JSR;
							break;
						case 0x16 :
							microstate = JSRZ;
							break;
						case 0x17 :
							microstate = JSRN;
							break;
						case 0x18 :
							microstate = DI;
							break;
						case 0x19 :
							microstate = EI;
							break;
						case 0x1A :
							microstate = RET;
							break;
						case 0x1B :
							microstate = RETI;
							break;			
						case 0x1C :
							microstate = TRAP;
							break;
						case 0x1D :
							microstate = HALT;
							break
						case 0x00 :
							microstate = NOP;
							break;	
					}
					
					state = EXECUTE;
							
				
			case EXECUTE :
				while(microstate < EXIT){
					//printf("ENTERED EXECUTE\n");
					
					//switch statement to handle the appropriate microstate
					switch(microstate) {
						case ADD :
							printf("In the ADD microstate\n");
							state = FETCH;	
							instruction = 0;
							microstate = EXIT;
							break;
						case NAND :
							printf("In the NAND microstate\n");
							state = FETCH;	
							instruction = 0;
							microstate = EXIT;
							break;
						case ADDI :
							printf("In the ADDI microstate\n");
							state = FETCH;	
							instruction = 0;
							microstate = EXIT;
							break;
						case LW :
							printf("In the LW microstate\n");
							state = FETCH;	
							instruction = 0;
							microstate = EXIT;
							break;
						case SW :
							printf("In the SW microstate\n");
							state = FETCH;	
							instruction = 0;
							microstate = EXIT;
							break;
						case BEQ :
							printf("In the BEQ microstate\n");
							state = FETCH;	
							instruction = 0;
							microstate = EXIT;
							break;
						case JALR :
							printf("In the JALR microstate\n");
							state = FETCH;	
							instruction = 0;
							microstate = EXIT;
							break;
						case HALT :
							printf("In the HALT microstate\n");
							state = HALT;
							microstate = EXIT;
							break;
					}

					printf("PC: %d,\t IR: %x,\t MAR: %d,\t A: %d,\t B: %d,\t RX: %d,\t RY: %d,\t RZ: %d,\n", myCPU->PC, myCPU->IR, myCPU->MAR, myCPU->ALUA, myCPU->ALUB, RX, RY, RZ);	
				}		
		}		
	}
	printf("\n");
	CPU_Destroy(myCPU);
	return (0);
	}
	
	
	//function to create a CPU struct
	struct CPU *create_CPU(){

	struct CPU *theCPU = malloc(sizeof(struct CPU));
	theCPU->PC = 0;
	theCPU->MAR = 0;
	theCPU->MDR = 0;
	theCPU->IR = 0;
	theCPU->ALUA = 0;
	theCPU->ALUB = 0;
	theCPU->ALUResult = 0;
	
	return theCPU;
	}
	
	//function to destroy a CPU struct
	void CPU_Destroy(struct CPU *theCPU){
		free(theCPU);
	}	
	
	//function to print register details and get user to press a key before continuing
	int pressAnyKey() {
		printf("REGISTER VALUES: \n");
		printf("Press Any Key to Continue: \n");
		
		//getch();
		//getch() is not available on OSX, this workaround was found on stack overflow
		// http://stackoverflow.com/questions/267250/equivalent-to-windows-getch-for-mac-linux-crashes
		system("read -n1 -p ' ' key"); 
		
		return 0;
	}